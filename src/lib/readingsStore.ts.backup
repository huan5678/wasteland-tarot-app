import { create } from 'zustand'
import { readingsAPI } from '@/lib/api'

export interface Reading {
  id: string
  user_id?: string
  question: string
  spread_type: string
  cards_drawn: any[]
  interpretation?: string
  character_voice?: string
  karma_context?: string
  faction_influence?: string
  created_at?: string
  updated_at?: string
  is_favorite?: boolean
  tags?: string[]
  notes?: string
}

interface ReadingsState {
  readings: Reading[]
  byId: Record<string, Reading>
  isLoading: boolean
  error: string | null
  lastFetched: number | null
  fetchUserReadings: (userId: string, force?: boolean) => Promise<void>
  createReading: (data: Omit<Reading, 'id'>) => Promise<Reading | null>
  updateReading: (id: string, data: Partial<Reading>) => Promise<Reading | null>
  deleteReading: (id: string) => Promise<boolean>
  toggleFavorite: (id: string) => Promise<void>
  clearError: () => void
}

const CACHE_TTL = 5 * 60 * 1000 // 5 minutes

export const useReadingsStore = create<ReadingsState>((set, get) => ({
  readings: [],
  byId: {},
  isLoading: false,
  error: null,
  lastFetched: null,

  fetchUserReadings: async (userId: string, force = false) => {
    const { lastFetched, isLoading } = get()
    if (!force && !isLoading && lastFetched && Date.now() - lastFetched < CACHE_TTL) return
    set({ isLoading: true, error: null })
    try {
      const data = await readingsAPI.getUserReadings(userId)
      const map: Record<string, Reading> = {}
      data.forEach(r => { map[r.id] = r })
      set({ readings: data, byId: map, isLoading: false, lastFetched: Date.now() })
    } catch (e: any) {
      set({ error: e?.message || '讀取占卜失敗', isLoading: false })
    }
  },

  createReading: async (data) => {
    set({ isLoading: true, error: null })
    try {
      // API expects different field names (cards_drawn etc.) - adapt
      const created = await readingsAPI.create({
        question: data.question,
        spread_type: data.spread_type,
        cards_drawn: data.cards_drawn,
        interpretation: data.interpretation,
        character_voice: data.character_voice,
        karma_context: data.karma_context,
        faction_influence: data.faction_influence
      })
      set(state => ({
        readings: [created, ...state.readings],
        byId: { ...state.byId, [created.id]: created },
        isLoading: false
      }))
      return created
    } catch (e: any) {
      set({ error: e?.message || '建立占卜失敗', isLoading: false })
      return null
    }
  },

  updateReading: async (id, data) => {
    set({ isLoading: true, error: null })
    try {
      const updated = await readingsAPI.update(id, data)
      set(state => ({
        readings: state.readings.map(r => r.id === id ? updated : r),
        byId: { ...state.byId, [id]: updated },
        isLoading: false
      }))
      return updated
    } catch (e: any) {
      set({ error: e?.message || '更新占卜失敗', isLoading: false })
      return null
    }
  },

  deleteReading: async (id) => {
    set({ isLoading: true, error: null })
    try {
      await readingsAPI.delete(id)
      set(state => {
        const { [id]: _, ...rest } = state.byId
        return {
          readings: state.readings.filter(r => r.id !== id),
          byId: rest,
          isLoading: false
        }
      })
      return true
    } catch (e: any) {
      set({ error: e?.message || '刪除占卜失敗', isLoading: false })
      return false
    }
  },

  toggleFavorite: async (id) => {
    const current = get().byId[id]
    if (!current) return
    // optimistic update
    set(state => {
      const reading = state.byId[id]
      if (!reading) return state
      const updated = { ...reading, is_favorite: !reading.is_favorite }
      return {
        readings: state.readings.map(r => r.id === id ? updated : r),
        byId: { ...state.byId, [id]: updated }
      }
    })
    try {
      await readingsAPI.update(id, { is_favorite: !current.is_favorite })
    } catch (e) {
      // rollback on failure
      set(state => {
        const reading = state.byId[id]
        if (!reading) return state
        const rolled = { ...reading, is_favorite: current.is_favorite }
        return {
          readings: state.readings.map(r => r.id === id ? rolled : r),
          byId: { ...state.byId, [id]: rolled }
        }
      })
    }
  },

  clearError: () => set({ error: null })
}))
